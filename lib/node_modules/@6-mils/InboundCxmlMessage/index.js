const debug = require('debug')('6-mils:InboundCxmlMessage')

const { DateTime } = require('luxon')
const { evaluateXPathToString } = require('fontoxpath')
const { sync } = require('slimdom-sax-parser')

/**
 * A collection of private property values for each instance of this class.
 * @type {WeakMap}
 */
const _private = new WeakMap()

/**
 * This base class is intended to provide the basic functionality for parsing
 * messages received from a supplier.
 */
class InboundCxmlMessage {
  constructor () {
    /**
     * The properties of the incoming message are set to reasonable defaults.
     * `parse()` will override these values with the ones specified in the cXML
     * message.
     */
    _private.set(this, {
      src: '',
      dom: null,
      payloadId: require('@6-mils/CxmlPayloadId')(),
      timestamp: DateTime.local().toString(),
      version: require('@6-mils/CxmlVersion'),
      statusCode: '200',
      statusText: 'success'
    })
  }

  get payloadId () {
    return _private.get(this).payloadId
  }

  get timestamp () {
    return _private.get(this).timestamp
  }

  get version () {
    return _private.get(this).version
  }

  get statusCode () {
    return _private.get(this).statusCode
  }

  get statusText () {
    return _private.get(this).statusText
  }

  /**
   * @param  {String}   src   The cXML message to parse.
   *
   * @return {undefined}
   */
  parse (src) {
    src = src || ''
    debug('Parsing "%s"', src)

    if (src.length === 0) {
      throw new Error('The parameter value for "parse" is required and must be a valid cXML string.')
    }

    const props = _private.get(this)

    try {
      props.dom = sync(src)
      props.src = src
    } catch (e) {
      throw new Error('The parameter value for "parse" is required and must be a valid cXML string.')
    }

    props.payloadId = evaluateXPathToString('/cXML/data(@payloadID)', props.dom).replace('"', '')
    props.timestamp = evaluateXPathToString('/cXML/data(@timestamp)', props.dom).replace('"', '')

    props.version = /\d\.\d+\.\d+/.exec(props.dom.childNodes[0].publicId)[0]

    props.statusCode = evaluateXPathToString('/cXML/Response/Status/data(@code)', props.dom).replace('"', '')
    props.statusText = evaluateXPathToString('/cXML/Response/Status/text()', props.dom).replace('"', '')

    _private.set(this, props)
  }

  /**
   * [query description]
   * @param  {[type]} path [description]
   * @return {[type]}      [description]
   */
  query (path) {
    path = path || ''

    if (path.length === 0) {
      throw new Error('The parameter value for "query" is required and must be a string containing a valid XPath expression.')
    }

    try {
      return evaluateXPathToString(path, _private.get(this).dom)
    } catch (e) {
      if (e.message.match(/xpathExpression must be a string/)) {
        throw new Error('The parameter value for "query" is required and must be a string containing a valid XPath expression.')
      }

      if (e.message.match(/^XPST0003: Unable to parse/)) {
        throw new Error('The parameter value for "query" is required and must be a string containing a valid XPath expression.')
      }

      throw e
    }
  }
}

module.exports = InboundCxmlMessage
