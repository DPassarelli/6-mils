const debug = require('debug')('6-mils:InboundCxmlMessage')

const { DateTime } = require('luxon')
const { evaluateXPathToString } = require('fontoxpath')
const { sync } = require('slimdom-sax-parser')

/**
 * A collection of private property values for each instance of this class.
 * @type {WeakMap}
 */
const _private = new WeakMap()

/**
 * A wrapper for the XPath query engine. This makes it easier to provide
 * consistent functionality wherever an XPath expression needs to be evaluated.
 *
 * @param  {String}     xpath   A valid XPath expression.
 *
 * @param  {SlimDom}    dom     The DOM to execute the expression against.
 *
 * @return {String}
 */
function getXmlValue (xpath, dom) {
  return evaluateXPathToString(xpath, dom)
}

/**
 * This base class is intended to provide the basic functionality for parsing
 * messages received from a supplier.
 */
class InboundCxmlMessage {
  constructor () {
    /**
     * The properties of the incoming message are set to reasonable defaults.
     * `parse()` will override these values with the ones specified in the cXML
     * message.
     */
    _private.set(this, {
      src: '',
      dom: null,
      payloadId: require('@6-mils/CxmlPayloadId')(),
      timestamp: DateTime.local().toString(),
      version: require('@6-mils/CxmlVersion'),
      statusCode: '200',
      statusText: 'success'
    })
  }

  /**
   * @readonly
   * @return {String?}   The value of the "payloadID" attribute of the "cXML"
   *                     element.
   */
  get payloadId () {
    return _private.get(this).payloadId || null
  }

  /**
   * @readonly
   * @return {String?}   The value of the "timestamp" attribute of the "cXML"
   *                     element.
   */
  get timestamp () {
    return _private.get(this).timestamp || null
  }

  /**
   * @readonly
   * @return {String?}   The value of the DTD version used by this cXML message
   *                     (obtained from the DOCTYPE element).
   */
  get version () {
    return _private.get(this).version || null
  }

  /**
   * @readonly
   * @return {String?}   The value of the "code" attribute of the "Status"
   *                     element.
   */
  get statusCode () {
    return _private.get(this).statusCode || null
  }

  /**
   * @readonly
   * @return {String?}   Either the inner text of the "Status" element, or the
   *                     value of the "text" attribute, if the former is not
   *                     given.
   */
  get statusText () {
    return _private.get(this).statusText || null
  }

  /**
   * Parses the given cXML message, and updates the property values of this
   * instance. The parsed message is saved in memory for future use by the
   * "query" method.
   *
   * @param  {String}   src   The cXML message to parse.
   *
   * @return {undefined}
   */
  parse (src) {
    src = src || ''
    debug('Parsing "%s"', src)

    if (src.length === 0) {
      throw new Error('The parameter value for "parse" is required and must be a valid cXML string.')
    }

    const props = _private.get(this)

    try {
      props.dom = sync(src)
      props.src = src
    } catch (e) {
      // invalidate instance members
      _private.set(this, {})

      // throw
      throw new Error('The parameter value for "parse" is required and must be a valid cXML string.')
    }

    props.payloadId = getXmlValue('/cXML/data(@payloadID)', props.dom)
    props.timestamp = getXmlValue('/cXML/data(@timestamp)', props.dom)

    props.version = /\d\.\d+\.\d+/.exec(props.dom.childNodes[0].publicId)[0]

    props.statusCode = getXmlValue('/cXML/Response/Status/data(@code)', props.dom)
    props.statusText = getXmlValue('/cXML/Response/Status/text()', props.dom)

    if (props.statusText.length === 0) {
      props.statusText = getXmlValue('/cXML/Response/Status/data(@text)', props.dom)
    }

    _private.set(this, props)
  }

  /**
   * [query description]
   * @param  {[type]} path [description]
   * @return {[type]}      [description]
   */
  query (path) {
    path = path || ''

    if (path.length === 0) {
      throw new Error('The parameter value for "query" is required and must be a string containing a valid XPath expression.')
    }

    try {
      return getXmlValue(path, _private.get(this).dom)
    } catch (e) {
      if (e.message.match(/xpathExpression must be a string/)) {
        throw new Error('The parameter value for "query" is required and must be a string containing a valid XPath expression.')
      }

      if (e.message.match(/^XPST0003: Unable to parse/)) {
        throw new Error('The parameter value for "query" is required and must be a string containing a valid XPath expression.')
      }

      if (e.message.match(/^XPDY0002: context is absent/)) {
        throw new Error('There is nothing to query. Call "parse" with valid cXML first, and then call "query".')
      }

      throw e
    }
  }
}

module.exports = InboundCxmlMessage
