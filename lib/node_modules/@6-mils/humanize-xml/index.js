/**
 * Pretty-prints a cXML document with indentation. Only intended for creating
 * human-readable representations.
 *
 * @param  {String}   src   The cXML to format (no whitespace is expected
 *                          between tags).
 *
 * @return {String}
 */
function humanizeXml (src) {
  /**
   * As the source XML is parsed for formatting, it will be added to this array
   * line by line.
   * @type {Array}
   */
  const output = []

  /**
   * The level of indentation for the current line.
   * @type {Number}
   */
  let currentIndentationLevel = 0

  /**
   * The characters to use for indentation.
   * @type {String}
   */
  const indent = '  '

  /**
   * The next-to-most-recent tag encountered by this parser. The starting value
   * is set to the first expected element.
   * @type {String}
   */
  let previousTagName = 'cXML'

  /**
   * The most-recent tag encountered by this parser.
   * @type {String}
   */
  let currentTagName = ''

  const lines = src.split('>')

  /**
   * The last line to include. This is purposefully set as the second-to-last
   * because it is easier (processing-wise) to simply add a trailing "</cXML>"
   * tag outside the loop.
   * @type {Number}
   */
  const lastIndex = lines.length - 2

  for (let i = 0; i < lastIndex; i++) {
    const line = lines[i]

    // the first three lines are all left-aligned (xml, doctype, cXML)
    if (i < 3) {
      output.push(`${line}>`)
      continue
    }

    const tagName = /^<\/?(\w+)/.exec(line)
    if (tagName) currentTagName = tagName[1]

    if (line.startsWith('</')) {
      // closing tag, align with opening
      currentIndentationLevel--

      if (output[output.length - 2].endsWith('>') && currentTagName === previousTagName) {
        // this element had no children, so place ending tag on the same line as the starting
        output[output.length - 1] = `${output[output.length - 1]}${line}>`
      } else {
        // this element had children, so place ending tag on a new line
        output.push(`${indent.repeat(currentIndentationLevel)}${line}>`)
      }
    } else if (line.startsWith('<')) {
      // new element
      currentIndentationLevel++
      output.push(`${indent.repeat(currentIndentationLevel)}${line}>`)

      // if this is an empty element without a separate closing tag, then reset
      // the indentation level so that the next line will be properly aligned
      // with this one
      if (line.endsWith('/')) currentIndentationLevel--
    } else {
      // not an tag, so add to the end of the previous line
      output[output.length - 1] = `${output[output.length - 1]}${line}>`
    }

    previousTagName = currentTagName
  }

  output.push('</cXML>')

  return output.join('\n')
}

module.exports = humanizeXml
