/**
 * Pretty-prints a cXML document with indentation. Only intended for creating
 * human-readable representations.
 *
 * @param  {String}   src   The cXML to format (no whitespace is expected
 *                          between tags).
 *
 * @return {String}
 */
function humanizeXml (src) {
  /**
   * As the source XML is parsed for formatting, it will be added to this array
   * line by line.
   * @type {Array}
   */
  const output = []

  /**
   * The characters to use for indentation.
   * @type {String}
   */
  const indent = '  '

  /**
   *
   * @type {Array}
   */
  const currentTagHierarchy = ['cXML']

  /**
   * [lines description]
   * @type {[type]}
   */
  const lines = src.split('>')

  /**
   * The last line to include. This is purposefully set as the second-to-last
   * because it is easier (processing-wise) to simply add a trailing "</cXML>"
   * tag outside the loop.
   * @type {Number}
   */
  const lastIndex = lines.length - 2

  for (let i = 0; i < lastIndex; i++) {
    const currentLine = lines[i]

    // the first three lines are all left-aligned (xml, doctype, cXML)
    if (i < 3) {
      output.push(`${currentLine}>`)
      continue
    }

    const openingTagName = /^<(\w+)/.exec(currentLine)
    const closingTagName = /^<\/(\w+)/.exec(currentLine)

    if (openingTagName) {
      output.push(`${indent.repeat(currentTagHierarchy.length)}${currentLine}>`)

      if (!currentLine.endsWith('/')) {
        currentTagHierarchy.push(openingTagName[1])
      }
    } else if (closingTagName) {
      currentTagHierarchy.pop()
      output.push(`${indent.repeat(currentTagHierarchy.length)}${currentLine}>`)
    } else {
      output[output.length - 1] = `${output[output.length - 1]}${currentLine}>`
      currentTagHierarchy.pop()
    }
  }

  output.push('</cXML>')

  return output.join('\n')
}

module.exports = humanizeXml
