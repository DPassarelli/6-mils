module.exports = function (src) {
  /**
   * [lines description]
   * @type {Array}
   */
  const lines = []

  /**
   * [currentIndentationLevel description]
   * @type {Number}
   */
  let currentIndentationLevel = 0

  /**
   * [previousTagName description]
   * @type {String}
   */
  let previousTagName = ''

  /**
   * [currentTagName description]
   * @type {String}
   */
  let currentTagName = ''

  /**
   * [indent description]
   * @type {String}
   */
  const indent = '  '

  src.split('>').forEach((line, index) => {
    const tagName = /^<\/?(\w+)/.exec(line)

    switch (index) {
      case 0:
      case 1:
      case 2:
        lines.push(`${line}>`)
        break

      default:
        if (tagName) currentTagName = tagName[1]

        if (line.startsWith('</')) {
          currentIndentationLevel--

          if (lines[lines.length - 2].endsWith('>') && currentTagName === previousTagName) {
            // this element had no children, so place ending tag on the previous line
            lines[lines.length - 1] = `${lines[lines.length - 1]}${line}>`
          } else {
            // this element had children, so add new line
            lines.push(`${indent.repeat(currentIndentationLevel)}${line}>`)
          }
        } else if (line.startsWith('<')) {
          // new element
          currentIndentationLevel++
          lines.push(`${indent.repeat(currentIndentationLevel)}${line}>`)
        } else {
          // not an element, so add to the end of the previous line
          lines[lines.length - 1] = `${lines[lines.length - 1]}${line}>`
        }
    }

    previousTagName = currentTagName
  })

  lines[lines.length - 1] = lines[lines.length - 1].replace('>>', '>')

  return lines.join('\n')
}
